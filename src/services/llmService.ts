// src/services/llmService.ts

import { GoogleGenAI } from "@google/genai";
import { SalaryStatistics } from "@/models/statistics";
import { UserSkills, JobMatchResult } from "@/models/jobMatch";
import { config } from "@/config";

/**
 * Service LLM (Google Gemini) pour :
 * - Mapping s√©mantique des m√©tiers
 * - G√©n√©ration de r√©sum√©s statistiques en langage naturel
 * - Parsing de descriptions de m√©tiers
 * - Job matching bas√© sur comp√©tences
 */

let genAI: GoogleGenAI | null = null;

/**
 * Initialise le client Gemini (nouvelle API @google/genai)
 */
function getGenAI(): GoogleGenAI {
  if (!config.llm.apiKey) {
    console.error("[LLM] ‚ùå ERREUR: Cl√© API Gemini manquante!");
    console.error(
      "[LLM] üí° Assure-toi que VITE_GEMINI_API_KEY est dans ton .env"
    );
    throw new Error("Cl√© API Gemini manquante dans la configuration");
  }

  if (!genAI) {
    genAI = new GoogleGenAI({ apiKey: config.llm.apiKey });
    console.log(
      "[LLM] ‚úÖ Client Gemini initialis√© (nouvelle API @google/genai)"
    );
    console.log(
      "[LLM] üîë Cl√© API (premiers 10 chars):",
      config.llm.apiKey.substring(0, 10) + "..."
    );
    console.log("[LLM] ü§ñ Mod√®le utilis√©:", config.llm.model);
  }

  return genAI;
}

/**
 * Parse le JSON depuis une r√©ponse LLM (robuste)
 */
function parseJSONFromLLM(response: string): Record<string, unknown> {
  console.log("[LLM] üîç D√©but parsing JSON...");

  let cleaned = response.trim();

  if (!cleaned) {
    console.error("[LLM] ‚ùå R√©ponse vide pour le parsing");
    throw new Error("R√©ponse vide");
  }

  // Enlever les markdown code blocks
  cleaned = cleaned.replace(/```json\s*/gi, "").replace(/```\s*/g, "");

  // Enlever tout texte avant le premier {
  const startIndex = cleaned.indexOf("{");
  if (startIndex === -1) {
    console.error(
      "[LLM] ‚ùå Aucun JSON trouv√© dans la r√©ponse:",
      cleaned.substring(0, 300)
    );
    throw new Error("Aucun JSON trouv√©");
  }

  if (startIndex > 0) {
    console.log(
      "[LLM] üßπ Texte avant JSON supprim√©:",
      cleaned.substring(0, startIndex)
    );
    cleaned = cleaned.substring(startIndex);
  }

  // Enlever tout texte apr√®s le dernier }
  const endIndex = cleaned.lastIndexOf("}");
  if (endIndex === -1) {
    console.error("[LLM] ‚ùå Pas de fermeture } trouv√©e");
    throw new Error("JSON incomplet");
  }

  if (endIndex < cleaned.length - 1) {
    console.log(
      "[LLM] üßπ Texte apr√®s JSON supprim√©:",
      cleaned.substring(endIndex + 1)
    );
    cleaned = cleaned.substring(0, endIndex + 1);
  }

  console.log(
    "[LLM] üìÑ JSON nettoy√© (premiers 300 chars):",
    cleaned.substring(0, 300)
  );

  const parsed = JSON.parse(cleaned);
  console.log("[LLM] ‚úÖ JSON pars√© avec succ√®s:", Object.keys(parsed));

  return parsed;
}

/**
 * Fonction utilitaire pour appeler le LLM avec gestion d'erreurs
 * Utilise la nouvelle API @google/genai
 */
async function callLLM(prompt: string): Promise<string> {
  try {
    const ai = getGenAI();

    console.log(
      "[LLM] üì§ Envoi prompt (premiers 200 chars):",
      prompt.substring(0, 200)
    );

    // Nouvelle syntaxe API @google/genai
    const response = await ai.models.generateContent({
      model: config.llm.model,
      contents: prompt,
      config: {
        temperature: config.llm.temperature,
        maxOutputTokens: config.llm.maxTokens,
      },
    });

    console.log("[LLM] üîç R√©ponse API compl√®te:", response);

    const text = response.text || "";

    if (!text || text.trim().length === 0) {
      console.error("[LLM] ‚ö†Ô∏è R√©ponse vide du LLM!");
      console.error(
        "[LLM] üìã Debug - response:",
        JSON.stringify(response, null, 2)
      );
      throw new Error("R√©ponse vide du LLM");
    }

    console.log(
      "[LLM] üì• R√©ponse brute (premiers 500 chars):",
      text.substring(0, 500)
    );
    console.log(
      "[LLM] üìè Longueur totale de la r√©ponse:",
      text.length,
      "caract√®res"
    );

    return text;
  } catch (error) {
    console.error("[LLM] ‚ùå Erreur lors de l'appel:", error);
    console.error(
      "[LLM] üí° D√©tails:",
      error instanceof Error ? error.message : String(error)
    );
    throw new Error(
      "Erreur lors de la communication avec l'IA. Veuillez r√©essayer."
    );
  }
}

/**
 * 1Ô∏è‚É£ Mappe l'entr√©e utilisateur vers des titres exacts de la DB
 *
 * Exemple:
 * Input: "java dev"
 * Output: ["Java Developer", "D√©veloppeur Java", "Java Software Engineer"]
 */
export async function mapJobTitlesToDatabase(
  userInput: string,
  allTitles: string[]
): Promise<string[]> {
  if (!config.features.naturalLanguageSearch) {
    // Fallback: recherche simple par inclusion de string
    const normalized = userInput.toLowerCase();
    return allTitles.filter((title) =>
      title.toLowerCase().includes(normalized)
    );
  }

  try {
    console.log("[LLM] üîç mapJobTitlesToDatabase - Input:", userInput);
    console.log("[LLM] üìä Nombre de titres disponibles:", allTitles.length);

    // ‚ö†Ô∏è LIMITE: R√©duire √† 850 titres pour √©viter de d√©passer le contexte Gemini
    const limitedTitles = allTitles.slice(0, 850);
    console.log("[LLM] üìã Titres limit√©s √†:", limitedTitles.length);
    if (allTitles.length > 850) {
      console.warn(
        `[LLM] ‚ö†Ô∏è ${
          allTitles.length - 850
        } titres ignor√©s pour rester sous la limite de tokens`
      );
    }

    const prompt = `Tu es FOX, expert senior en classification de m√©tiers tech avec 15 ans d'exp√©rience dans l'analyse salariale et l'orientation de carri√®re. Tu ma√Ætrises parfaitement les nuances entre m√©tiers similaires, les √©volutions de titres dans l'industrie, et les √©quivalences internationales.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üéØ MISSION CRITIQUE - MATCHING PR√âCIS DE M√âTIERS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Identifier UNIQUEMENT les titres de poste qui correspondent R√âELLEMENT au m√™me m√©tier que l'entr√©e utilisateur. √âVITE les matchs trop larges qui nuisent √† la pertinence.

üì• ENTR√âE UTILISATEUR : "${userInput}"

üìã BASE DE DONN√âES (Titres disponibles) :
${limitedTitles.map((title, idx) => `${idx + 1}. ${title}`).join("\n")}

‚öôÔ∏è R√àGLES STRICTES DE MATCHING :
1. Retourne UNIQUEMENT des titres EXACTS pr√©sents dans la liste ci-dessus
2. Consid√®re les variantes linguistiques et orthographiques du M√äME m√©tier :
   ‚Ä¢ "dev" = "developer" = "d√©veloppeur" = "software engineer"
   ‚Ä¢ "Fullstack" = "Full Stack" = "Full-Stack"
3. G√®re les niveaux d'exp√©rience intelligemment :
   ‚Ä¢ Si "senior/lead/principal" dans l'input ‚Üí priorise ces titres
   ‚Ä¢ Si "junior/d√©butant" ‚Üí priorise ces titres
   ‚Ä¢ Si pas de niveau sp√©cifi√© ‚Üí inclus TOUS les niveaux

üö® R√àGLES D'EXCLUSION CRITIQUE (d√©tail important !) :
‚ùå NE MATCHE PAS des m√©tiers diff√©rents m√™me s'ils sont dans le m√™me domaine par exemple :
   ‚Ä¢ "CloudOps" ‚â† "Administrateur Syst√®me" (responsabilit√©s diff√©rentes)
   ‚Ä¢ "CloudOps" ‚â† "Architecte Infra" (niveau et scope diff√©rents)
   ‚Ä¢ "DevOps" ‚â† "SRE" (m√©tiers distincts malgr√© similarit√©s)
   ‚Ä¢ "Data Scientist" ‚â† "Data Engineer" (m√©tiers tr√®s diff√©rents)
   ‚Ä¢ "Backend Developer" ‚â† "Full Stack Developer" (sp√©cialisations diff√©rentes)
   ‚Ä¢ "Mobile Developer" ‚â† "Frontend Developer" (plateformes diff√©rentes)

‚úÖ MATCHE UNIQUEMENT :
   ‚Ä¢ Variantes orthographiques EXACTES du m√™me poste
   ‚Ä¢ Traductions FR/EN du m√™me poste
   ‚Ä¢ Abr√©viations communes du m√™me poste
   ‚Ä¢ Niveaux diff√©rents du M√äME m√©tier (si niveau non sp√©cifi√©)

üìä EXEMPLES DE MATCHING CORRECT :
   Input: "CloudOps" ‚Üí Match: "Cloud Ops", "Cloud Operations Engineer", "CloudOps Engineer"
   Input: "CloudOps" ‚Üí ‚ùå PAS: "Administrateur Syst√®me", "DevOps", "Architecte Infra"
   
   Input: "Data Scientist" ‚Üí Match: "Data Scientist", "Scientist Data", "Senior Data Scientist"
   Input: "Data Scientist" ‚Üí ‚ùå PAS: "Data Engineer", "Data Analyst", "ML Engineer"
   
   Input: "Backend Developer" ‚Üí Match: "Backend Developer", "D√©veloppeur Backend", "Backend Engineer"
   Input: "Backend Developer" ‚Üí ‚ùå PAS: "Full Stack Developer", "DevOps Engineer"

üéØ FORMAT DE R√âPONSE (JSON STRICT - PAS D'AUTRE TEXTE) :
{
  "matches": ["Titre Exact 1", "Titre Exact 2", "Titre Exact N"],
  "reasoning": "Explication ultra-br√®ve de ton matching strict (1 phrase max)"
}

‚ö†Ô∏è IMP√âRATIF : R√©ponds UNIQUEMENT avec le JSON valide. Aucun markdown, aucun commentaire. SOIS STRICT dans les correspondances pour √©viter les faux positifs.`;

    const response = await callLLM(prompt);

    try {
      const parsed = parseJSONFromLLM(response);
      const matches = (parsed.matches as string[]) || [];
      console.log("[LLM] ‚úÖ Matches trouv√©s:", matches.length, "titres");
      return matches;
    } catch (parseError) {
      console.error("[LLM] ‚ùå Erreur parsing JSON:", parseError);
      console.error("[LLM] üìÑ R√©ponse compl√®te:", response);
      // Fallback: recherche simple
      console.log("[LLM] üîÑ Fallback: recherche locale simple");
      const normalized = userInput.toLowerCase();
      const fallbackResults = allTitles
        .filter((title) => title.toLowerCase().includes(normalized))
        .slice(0, 10);
      console.log("[LLM] üîÑ Fallback r√©sultats:", fallbackResults.length);
      return fallbackResults;
    }
  } catch (error) {
    console.error("[LLM] Erreur mapJobTitlesToDatabase:", error);
    // Fallback sur recherche simple
    const normalized = userInput.toLowerCase();
    return allTitles
      .filter((title) => title.toLowerCase().includes(normalized))
      .slice(0, 10);
  }
}

/**
 * 2Ô∏è‚É£ G√©n√®re un r√©sum√© statistique en langage naturel
 */
export async function generateStatsSummary(
  stats: SalaryStatistics,
  jobTitles?: string[]
): Promise<string> {
  if (!config.features.aiSummary) {
    return `Salaire moyen de ${Math.round(stats.mean)}‚Ç¨ sur ${
      stats.count
    } salaires analys√©s.`;
  }

  try {
    // Pr√©parer le contexte des titres
    const titlesContext =
      jobTitles && jobTitles.length > 0
        ? `\nüìã POSTES CONCERN√âS : ${jobTitles.slice(0, 5).join(", ")}${
            jobTitles.length > 5 ? ` et ${jobTitles.length - 5} autres` : ""
          }`
        : "";

    const prompt = `Tu es Fox, expert en salaires tech. R√©dige un r√©sum√© ULTRA-CLAIR, organis√© en POINTS COURTS, adapt√© mobile (pas de colonnes, pas de phrases trop longues).${titlesContext}

üìä DONN√âES (${stats.count} salaires analys√©s) :
‚Ä¢ Salaire m√©dian (typique) : ${Math.round(stats.median)}‚Ç¨/an
‚Ä¢ Fourchette globale : ${Math.round(stats.min)}‚Ç¨ ‚Üí ${Math.round(stats.max)}‚Ç¨
‚Ä¢ 50% gagnent PLUS de ${Math.round(stats.quartiles.median)}‚Ç¨
‚Ä¢ 25% gagnent MOINS de ${Math.round(stats.quartiles.q1)}‚Ç¨

üíº √âVOLUTION AVEC L'EXP√âRIENCE :
‚Ä¢ Juniors (0-2 ans) : ${Math.round(stats.leastExperiencedAvg)}‚Ç¨ en moyenne
${
  stats.juniorMaxSalary
    ? `‚Ä¢ üèÜ Meilleur junior : ${Math.round(stats.juniorMaxSalary)}‚Ç¨ - ${
        stats.juniorMaxDetails
      }`
    : ""
}
‚Ä¢ Seniors (10+ ans) : ${Math.round(stats.mostExperiencedAvg)}‚Ç¨ en moyenne
${
  stats.seniorMaxSalary
    ? `‚Ä¢ üèÜ Meilleur senior : ${Math.round(stats.seniorMaxSalary)}‚Ç¨ - ${
        stats.seniorMaxDetails
      }`
    : ""
}

üéØ STRUCTURE OBLIGATOIRE (phrases courtes, claires, mobile-first) :
${
  jobTitles && jobTitles.length > 1
    ? `0. Une phrase mentionnant les postes concern√©s (si plusieurs, cite "pour X, Y et Z" ou "pour X, Y et autres")`
    : jobTitles && jobTitles.length === 1
    ? `0. Une phrase mentionnant le poste concern√© : "${jobTitles[0]}"`
    : ""
}
1. Une phrase sur le salaire typique (m√©diane)
2. Une phrase sur l'√©volution junior ‚Üí senior avec les moyennes
3. Une phrase mentionnant le meilleur profil junior si disponible
4. Une phrase mentionnant le meilleur profil senior si disponible
5. Une phrase d'encouragement ou conseil actionnable

‚úçÔ∏è R√àGLES D'OR :
‚Ä¢ PHRASES COURTES (15-20 mots max chacune)
‚Ä¢ AUCUN jargon technique (pas "quartile", "√©cart-type", etc.)
‚Ä¢ REFORMULE simplement : "50% gagnent plus de X‚Ç¨" au lieu de "m√©diane"
‚Ä¢ TON conversationnel et encourageant
‚Ä¢ MOBILE-FIRST : pas de mise en page complexe, juste des phrases qui se lisent facilement

‚ùå INTERDICTIONS :
‚Ä¢ Markdown, JSON, titres
‚Ä¢ Phrases de plus de 25 mots
‚Ä¢ Formulations techniques ou corporate
‚Ä¢ Oublier de mentionner les meilleurs profils junior/senior

‚úÖ EXEMPLE (ton attendu) :
"Le salaire typique est de 50k‚Ç¨. En d√©but de carri√®re, on d√©marre autour de 38k‚Ç¨. Avec l'exp√©rience (10+ ans), on atteint facilement 65k‚Ç¨. Le meilleur junior gagne 52k‚Ç¨ chez Scaleway √† Paris. Le meilleur senior atteint 120k‚Ç¨ chez Google. La moiti√© des pros gagnent plus de 48k‚Ç¨. Pour viser le haut, sp√©cialise-toi sur les technos cloud !"

R√©ponds UNIQUEMENT avec le texte du r√©sum√© :`;

    const response = await callLLM(prompt);
    return response.trim();
  } catch (error) {
    console.error("[LLM] Erreur generateStatsSummary:", error);
    return `Sur ${
      stats.count
    } salaires analys√©s, le salaire moyen est de ${Math.round(
      stats.mean
    )}‚Ç¨ avec une m√©diane √† ${Math.round(
      stats.median
    )}‚Ç¨. Les salaires varient de ${Math.round(stats.min)}‚Ç¨ √† ${Math.round(
      stats.max
    )}‚Ç¨.`;
  }
}

/**
 * 3Ô∏è‚É£ Parse une description de m√©tier en langage naturel
 *
 * Exemple:
 * Input: "je fais du react et du node, 3 ans d'xp"
 * Output: [{ title: "D√©veloppeur Fullstack", confidence: 92 }]
 */
export interface JobSuggestion {
  title: string;
  confidence: number; // 0-100
  reasoning?: string; // Justification courte de la recommandation
}

export async function parseNaturalLanguageJob(
  description: string
): Promise<JobSuggestion[]> {
  if (!config.features.naturalLanguageSearch) {
    return [];
  }

  try {
    const prompt = `Tu es FOX, conseiller expert en orientation de carri√®re tech avec connaissance encyclop√©dique des m√©tiers du num√©rique et de leurs √©volutions. Tu comprends les aspirations, comp√©tences et contextes vari√©s des professionnels tech.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîç ANALYSE DE PROFIL
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Description utilisateur : "${description}"

üéØ MISSION : Identifier 1 √† 3 m√©tiers tech correspondant parfaitement √† cette description

üß† ANALYSE REQUISE :
1. Identifie les technologies/outils mentionn√©s
2. D√©tecte le niveau d'exp√©rience (si mentionn√©)
3. Comprends le contexte (√©tudes, projets, aspirations)
4. √âvalue les soft skills implicites
5. D√©tecte les indices de sp√©cialisation (frontend/backend/fullstack/data/etc.)

üìä SCORING (0-100) :
‚Ä¢ 90-100 : Correspondance parfaite, tous les signaux align√©s
‚Ä¢ 75-89 : Tr√®s bonne correspondance, quelques gaps mineurs
‚Ä¢ 60-74 : Correspondance correcte, n√©cessite mont√©e en comp√©tence
‚Ä¢ <60 : Ne pas proposer (trop √©loign√© du profil)

‚öôÔ∏è R√àGLES STRICTES :
‚Ä¢ Maximum 3 m√©tiers, par ordre d√©croissant de score
‚Ä¢ M√©tiers tech uniquement (d√©veloppement, data, devops, cybers√©curit√©, etc.)
‚Ä¢ Noms de m√©tiers en FRAN√áAIS et standardis√©s
‚Ä¢ Scores r√©alistes bas√©s sur les indices r√©els de la description
‚Ä¢ Si description vague/incompl√®te : scores plus conservateurs

üéØ FORMAT DE R√âPONSE (JSON STRICT) :
{
  "suggestions": [
    {
      "title": "D√©veloppeur Full Stack",
      "confidence": 88,
      "reasoning": "Ma√Ætrise React et Node.js mentionn√©e"
    }
  ]
}

‚ö†Ô∏è IMP√âRATIF : R√©ponds UNIQUEMENT avec du JSON valide, aucun markdown, aucun texte additionnel.`;

    const response = await callLLM(prompt);

    try {
      const parsed = parseJSONFromLLM(response);
      return (parsed.suggestions as JobSuggestion[]) || [];
    } catch (parseError) {
      console.error("[LLM] Erreur parseNaturalLanguageJob:", parseError);
      return [];
    }
  } catch (error) {
    console.error("[LLM] Erreur parseNaturalLanguageJob:", error);
    return [];
  }
}

/**
 * 4Ô∏è‚É£ Match des m√©tiers bas√©s sur les comp√©tences utilisateur
 * Pour la fonctionnalit√© "TROUVER QUEL M√âTIER JE PEUX FAIRE"
 */
export async function matchJobsBySkills(
  skills: UserSkills
): Promise<JobMatchResult[]> {
  if (!config.features.jobMatcher) {
    return [];
  }

  try {
    // Pr√©parer la liste des roadmaps disponibles
    const availableRoadmaps = [
      ...config.roadmaps.roles.map((r) => `${r.name} (${r.url})`),
      ...config.roadmaps.skills.map((s) => `${s.name} (${s.url})`),
    ].join("\n");

    const prompt = `Tu es FOX, conseiller en orientation de carri√®re tech de niveau expert avec 15 ans d'exp√©rience. Tu as accompagn√© des centaines de d√©veloppeurs dans leur transition professionnelle. Tu connais parfaitement l'√©cosyst√®me tech, les comp√©tences recherch√©es, et les parcours d'apprentissage optimaux.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë§ PROFIL UTILISATEUR √Ä ANALYSER
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîß Technologies ma√Ætris√©es : ${skills.technologies.join(", ")}
üéì Formation : ${skills.education}
${
  skills.experience ? `‚è±Ô∏è Ann√©es d'exp√©rience : ${skills.experience} an(s)` : ""
}
${
  skills.additionalInfo
    ? `üí¨ Informations additionnelles : ${skills.additionalInfo}`
    : ""
}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üó∫Ô∏è ROADMAPS DISPONIBLES (roadmap.sh)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${availableRoadmaps}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üéØ TA MISSION D√âTAILL√âE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
1. Analyser en profondeur le profil (stack technique, niveau, contexte)
2. Identifier les 3 m√©tiers tech les PLUS adapt√©s (pas de g√©n√©rique, sois pr√©cis)
3. Pour chaque m√©tier :
   ‚Ä¢ Calculer un score de compatibilit√© r√©aliste (0-100)
   ‚Ä¢ Lister les comp√©tences qui MATCHENT d√©j√†
   ‚Ä¢ Lister les comp√©tences MANQUANTES critiques
   ‚Ä¢ Recommander 2-4 roadmaps roadmap.sh pertinentes (URLs compl√®tes)
   ‚Ä¢ Justifier bri√®vement pourquoi ce m√©tier correspond

üßÆ M√âTHODE DE SCORING (sois rigoureux) :
‚Ä¢ 85-100 : Profil quasi-id√©al, pr√™t pour le poste avec formations mineures
‚Ä¢ 70-84 : Tr√®s bon fit, n√©cessite mont√©e en comp√©tence cibl√©e (3-6 mois)
‚Ä¢ 55-69 : Fit correct, n√©cessite apprentissage cons√©quent (6-12 mois)
‚Ä¢ <55 : Ne pas proposer (trop de gaps)

‚öôÔ∏è R√àGLES CRITIQUES :
‚Ä¢ Maximum 3 m√©tiers, tri√©s par score d√©croissant
‚Ä¢ M√©tiers PR√âCIS (pas "D√©veloppeur" mais "D√©veloppeur Full Stack Node.js/React")
‚Ä¢ Roadmaps : s√©lectionne parmi celles list√©es ci-dessus (URLs exactes)
‚Ä¢ Comp√©tences manquantes : sois sp√©cifique et actionnable
‚Ä¢ Si profil junior : recommande des roadmaps fondamentales
‚Ä¢ Si profil senior : recommande des roadmaps avanc√©es/architecturales
‚Ä¢ Consid√®re le contexte (√©tudes, projets perso, aspirations)

üéØ FORMAT DE R√âPONSE (JSON STRICT - STRUCTURE EXACTE) :
{
  "matches": [
    {
      "jobTitle": "D√©veloppeur Backend Node.js",
      "compatibilityScore": 78,
      "matchedSkills": ["JavaScript", "Node.js", "REST APIs"],
      "missingSkills": ["TypeScript", "Docker", "PostgreSQL", "Tests unitaires"],
      "recommendedRoadmaps": [
        "https://roadmap.sh/nodejs",
        "https://roadmap.sh/backend",
        "https://roadmap.sh/docker",
        "https://roadmap.sh/postgresql-dba"
      ],
      "reasoning": "Solide base JavaScript et Node.js. Compl√©ter avec TypeScript et DevOps pour √™tre op√©rationnel en entreprise."
    }
  ]
}

‚ö†Ô∏è IMP√âRATIF ABSOLU :
‚Ä¢ R√©ponds UNIQUEMENT avec du JSON valide (pas de markdown, pas de commentaires)
‚Ä¢ URLs roadmap.sh EXACTES (issues de la liste fournie)
‚Ä¢ Noms de m√©tiers en fran√ßais, pr√©cis et standardis√©s
‚Ä¢ Scores coh√©rents avec les gaps identifi√©s`;

    const response = await callLLM(prompt);

    try {
      const parsed = parseJSONFromLLM(response);

      // Valider et enrichir les r√©sultats
      return ((parsed.matches as JobMatchResult[]) || []).map(
        (match: JobMatchResult) => ({
          jobTitle: match.jobTitle || "M√©tier inconnu",
          compatibilityScore: match.compatibilityScore || 0,
          averageSalary: 0, // Sera calcul√© par jobMatcher.ts
          matchedSkills: match.matchedSkills || [],
          missingSkills: match.missingSkills || [],
          recommendedRoadmaps: match.recommendedRoadmaps || [],
          reasoning: match.reasoning || "",
        })
      );
    } catch (parseError) {
      console.error("[LLM] Erreur matchJobsBySkills:", parseError);
      return [];
    }
  } catch (error) {
    console.error("[LLM] Erreur matchJobsBySkills:", error);
    return [];
  }
}
